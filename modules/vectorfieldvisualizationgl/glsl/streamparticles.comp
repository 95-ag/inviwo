uniform float stepLenght = 0.01; 
uniform int internalSteps = 10;
uniform sampler3D velocityField;

uniform float minV;
uniform float maxV;

uniform sampler2D tf;

layout(std430, binding=0) buffer posBuffer {    
    vec4 pos[];
};

layout(std430, binding=1) buffer lifeBuffer {    
    float life[];
};

layout(std430, binding=2) buffer radiBuffer {    
    float radius[];
};

layout(std430, binding=3) buffer colBuffer {    
    vec4 col[];
};

vec3 norm(vec3 v){
    bool doNormalize = false;
    if(doNormalize){    
        float l2 = dot(v,v);
        if(l2==0) return v;
        return v/sqrt(l2);
    }else{
        return v;
    }
    
}

vec4 getColor(float v) {
    v = (v - minV) / (maxV - minV);
    return texture(tf,vec2(v,0.5));
}

uniform mat4 toWorldMatrix;
uniform mat4 toTextureMatrix;
vec3 toWorld(vec3 p){
    vec4 P = toWorldMatrix * vec4(p,1);
    return P.xyz / P.w;
}

vec3 toTexture(vec3 p){
    vec4 P = toTextureMatrix * vec4(p,1);
    return P.xyz / P.w;
}

bool inside(vec3 p){
    if(p.x < 0) return false;
    if(p.y < 0) return false;
    if(p.z < 0) return false;
    if(p.x > 1) return false;
    if(p.y > 1) return false;
    if(p.z > 1) return false;
    return true;
}
 

vec3 sample_(vec3 p){
    vec3 tex = toTexture(p);
    if(!inside(tex)) return vec3(0);
    return texture(velocityField,tex).xyz; 
}

vec3 step(vec3 p){
    vec3 k1 = sample_(p); 
    vec3 k2 = sample_(p + norm(k1) * stepLenght*0.5);
    vec3 k3 = sample_(p + norm(k2) * stepLenght*0.5);
    vec3 k4 = sample_(p + norm(k3) * stepLenght);
    return p + normalize(k1)*stepLenght;  
    //return p + norm((k1+k2+k2+k3+k3+k4))*stepLenght;  
}

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1 ) in;
void main(){
    uint gid = gl_GlobalInvocationID.x;
    vec3 p = pos[gid].xyz; 
    
    for (int i = 0;i<internalSteps;i++){ 
        p = step(p); 
    } 

    float l = length(sample_(p));
    if(l<0.01){
        life[gid] = 0; 
    }

    float r = 0.5; 
    col[gid] = getColor(l); 
    r = mix(0,mix(0.1,0.5,l/maxV), life[gid]>0 );
    // if(life[gid]<=0){
    //     r = 0;
    // }else{
    //     r = ;
    // }
    radius[gid] = r;
    pos[gid] = vec4(p,1);
}   